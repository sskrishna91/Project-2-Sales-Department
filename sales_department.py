# -*- coding: utf-8 -*-
"""Sales Department.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vxr6cc9A6fOdYNVfbh1J8lvAR2pnqUe3

## Project 3
### **Sales Department**

** Hi! Everyone
Well come to this new case study for companies to become competative and Skyrocket their Growth and Sales.

* They need to leverage Artificial and Machine learning to develop a predctive modesl so they can be able to forecast Sales in the furture.

* Predictive models attampt at forecasting furture Sales based on historical data while taking into accounts. Seasonality affects and demand holidays promptions and competition.

* **In this Project** we work as a data scientist in the Sales department and the Sales team provided you with data from eleven hundred stores.

* The objective is to predctive furture daily Sales based on some features such as Stores promotions Store, Size school and state holidays, Distance away from compition and what type of products do therese stores carry.

* In this case study we are going to learn many Skills.

 ***Here are the main learning out comes:***

* Understand how to leverage the Power of data Science to predict furture product Sales.

* Understand the theory and intuition behind time Series forecasting models.

* Understand the thorey behind Facebook prophet time series forcasting tool.

* Understand the concept of additive regression

* List the adventages of Facebook Prophet.

* Apply Facebook Prophet to Predict future Sales using VR real wordl dataset.

* Predict furture **Weekly**, **Montly** and **Yearly** trends. 

### Let's get started

### Task#1:**UNDERSTAND THE PROBLEM STATEMENT AND BUSINESS CASE**

# INPUTS AND EXPECTED OUTPUTS

* **Id**: Transaction ID (Combination of Store and Data).
* **Store**: Unique store id
* **Sales**: Sales/Day, this is the target variable.
* **Customers**: number of customers on a given day
* **Open**: Boolean to day wheather a store is open or closed( 0 = closed, 1 = open)
* **Promo**: Describe if store is running a promot on that day or not. 
* **StateHoliday**: Indicate which state holiday(a = public holiday, b = Easter holiday, c = Christmas, 0 = None).
* **SchoolHoliday**: Indicate if the (Store, Date) was affected by the closure of public schools. 
* **StoreType**: Categorical variables to indicates type of store(a, b, c, d)
* **Assortment**: a = basic, b = extra, c= extended (Based on the size and location of the store)
* **CompetitionDistance(meters)**: Distance to closest competitor store.
* **CompetionOpenSince[Month/Year]**: Data When competion was open.
* **Promo2**: Promo2 is a continuing and consecutive promotion for Some stores (0 = Store is not participating, 1 = Store is participating).
* **Promo2 Since[Year/Week]**: Date when store started participating in Promo2
* **PromoInterval**: Describe the consuecutive intervals, Promo2 is started, naming the months promotion is started a new 
    * E.g: "Feb, May, Aug, Nov" means each round starts in February, May, August, November of any given year for that store.

### Task#2: **IMPORT LIBRARIES AND DATASET**
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import datetime

# Mount Google Drive
from google.colab import drive
drive.mount("/content/drive")

# Import SAles Training Data
# You have to include the full link to the CSV file containing your dataset
sales_train_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/DataScienceProjects/SalesDepartment/train.csv")
# Data Source: https://www.kaggle.com/c/rossmann-store-sales/data

sales_train_df

sales_train_df.head()

sales_train_df.columns

# Almost a million entries
# 1115 unique stores
# Sales is the target variable (that's what we are trying to predict)
# ID: Transaction ID (Combination of Store and Date)
# Store: Unique Store ID
# Sales: Sales/Day, this is target variable
# Customers: Number of customer on a given day.
# Open: 0 = closed, 1 = Open
# Promo: Describes if stores is running s promo on that day or not.
# StateHoliday: Indicates if the (Store, Date) was affected by the closure of public holiday.

# Let's check last 10 columns
sales_train_df.tail()

# Total 9 columsn: 
#Store
#DayOfWeek
#Date
#Sales
#Customers
#Open
#Promo
#StateHoliday
#SchoolHoliday

# 8 Features, each contains 1017208 data points
# 1 target variable(Sales)
sales_train_df.info()

sales_train_df.describe()

# Data Analysis
# Average Sales amount per day = 5573 Euros
# Average number of Customers = ~633
# Minimum number of Customers = 0
# Maximum number of Customers = 7388

"""### Task#2.2: **IMPORT STORE INFORMATION**"""

store_info_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/DataScienceProjects/SalesDepartment/store.csv")

store_info_df

store_info_df.head()

store_info_df.tail()

store_info_df.info()

store_info_df.describe()

store_info_df.columns

"""###  **Explore Store Data**
* **Store**: Store Unique ID,
* **StoreType**: Categorical variable to indicate type of store (a, b, c, d) 
* **Assortment**: Describes an assortment level(a = basic, b = extra, c = extended)
* **CompetitionDistance**:Distance to closest competition store
* **CompetitionOpenSince[Month/Year]**: Provides an estimate fo the date When competion was open.
* **Promo2**: Promo2 is a continuing and consecutive promotion for some stores (0 = Store is not participating, 1 = Store is participating)
* **Promo2Since[Week/Year]**: Date when the store started participating in Promo2
* **PromoInterval**:Describe the consecutive intervals Promo2 is started, naming the months the promotion is started a new 
    * E.g Feb, May, Aug, Nov" means

### Task#3: **EXPLORE BOTH SALES AND TRAINING DATASETS**

### Task#3.1: **EXPLORE SALES TRAIN DATA**
"""

# Let's see any if we have any missing data
sns.heatmap(sales_train_df.isnull(), yticklabels=False, cbar=False, cmap='Blues')

# Let's figure out the histogram diagram for Sales Train Data
sales_train_df.hist(bins = 30, figsize= (20, 20), color = 'r')

# Data Analysis
# Average 600 customers per day
# Maximum is 4500 (note that we can't see the outlier at 7388!)
# Data is equally distributed accross various Days of the week (~150000) observations  X 7 days = ~1.1 Million Observations.
# Stores are open 80% of the time
# Promo #1 was running ~40% of the time
# Average Sales around 5000-6000 EUROS
# School holidays are around ~18% of the time.

# Let's check maximum customers
sales_train_df['Customers'].max()
# Maxmimum customer per day 7388

# Let's see how many stores are open and closed
closed_train_df = sales_train_df[sales_train_df['Open'] == 0]
open_train_df = sales_train_df[sales_train_df['Open'] == 1]

closed_train_df

open_train_df

# Count the number of stores are Open and Closed
print("Total = ",len(sales_train_df))
print("Number of Open Stores: ", len(open_train_df))
print("Number of Closed Stores: ", len(closed_train_df))

# Only keep open stores and remove closed stores
sales_train_df = sales_train_df[sales_train_df['Open'] == 1]
sales_train_df

# Let's drop the open columns since it has no meaning now
sales_train_df.drop(['Open'], axis= 1, inplace= True)

sales_train_df

"""### Task#3.2 **EXPLORE STORES INFORMATION DATA**

"""

# Let's see if we have any missing data in the store information dataframe
sns.heatmap(store_info_df.isnull(), yticklabels= False, cbar = False, cmap= 'Blues')

# Let's take a look at the missing values in the 'CompetitionDistance' 
store_info_df[store_info_df['CompetitionDistance'].isnull()]

# Only three rows are missing

# Let's take a look at the missing values in the "CompetitionOpenSinceMonth"
store_info_df[store_info_df['CompetitionOpenSinceMonth'].isnull()]

# Many rows missing = 354(almost one thrid of the 1115 stores)

# Let's take a look at the missing values in the "CompetitionOpenSinceMonth"
store_info_df[store_info_df['CompetitionOpenSinceYear'].isnull()]

# Many rows missing = 354(almost one thrid of the 1115 stores)

# Let's see when Promo2 Zero
store_info_df[store_info_df['Promo2'] == 0]

# It seems like if 'Promo2' is Zero by default 'Promo2SinceWeek', 'Promo2SinceYear' and 'PromoInterval' information is set to Zero

# There are 354 rows where 'CompetitionSinceYear' and 'CompetitionOpenSinceMonth' is missing
# Let's set these values to Zeros
str_cols = ['Promo2SinceWeek', 'Promo2SinceYear', 'PromoInterval', 'CompetitionOpenSinceMonth', 'CompetitionOpenSinceYear'] 

for str in str_cols:
    store_info_df[str].fillna(0, inplace= True)

# Let's check the heat map to know missing values
sns.heatmap(store_info_df.isnull(), yticklabels= False, cbar= False, cmap= 'Blues')

# There are 3 rows with 'CompetitionDistance' values missing, let's fill them up with average value of the 'CompetitionDistance
store_info_df['CompetitionDistance'].fillna(store_info_df['CompetitionDistance'].mean(), inplace = True)

# Let's check the heat map to know missing values
sns.heatmap(store_info_df.isnull(), yticklabels= False, cbar= False, cmap= 'Blues')

# Let's go ahead and plot the histogram for my store info datafreame
store_info_df.hist(bins= 30, figsize=(20, 20), color = 'r')

# Half of store are involved in Promo2
# half of the stores have their competion at distance of 0-300m(3kms away)

"""### Task#3.3 **EXPLORE MERGED DATASET**

"""

# Let's merge both dataframes together based on 'Store'

sales_train_all_df = pd.merge(sales_train_df, store_info_df, how = 'inner', on = 'Store')

sales_train_all_df

# Let's take a look at the correlations between the data
correlations = sales_train_all_df.corr()['Sales'].sort_values()
correlations

# Customers and Promo are positively correlated with the sales
# Promo2 does not seem to be effictive at all

# The next step is now I can visualize our HeatMap and we can visualize all the Correlations in the just one diagram.

correlations = sales_train_all_df.corr()
f, ax = plt.subplots(figsize = (20, 20))
sns.heatmap(correlations, annot= True)

# Customer/Promo2 and Sales are strongly Correleted.

# Let's separate the Year and put it into a separate column.
sales_train_all_df['Year'] = pd.DatetimeIndex(sales_train_all_df['Date']).year

# Let's do the same for the Day and Month
sales_train_all_df['Month'] = pd.DatetimeIndex(sales_train_all_df['Date']).month

sales_train_all_df['Day'] = pd.DatetimeIndex(sales_train_all_df['Date']).day

sales_train_all_df

# Let's take a look at the average Sales and Number of customers per month
axis = sales_train_all_df.groupby('Month')[['Sales']].mean().plot(figsize = (10, 5), marker = 'o', color = 'r')
axis.set_title('Average Sales Per Month')
plt.figure()

# 'groupby' works great by grouping all the data that share the same month column, then obtain the mean of the Sales column

# It looks like Sales and Number of customers peak around christmas timeframe
axis = sales_train_all_df.groupby('Month')[['Customers']].mean().plot(figsize= (10, 5), marker = 'o', color = 'r')
axis.set_title("Average Customers Per Month")

# Let's take a look at the Sales and Customers per day of the Month instead
# Minimum number of customers are generally around the 24th of the Month
# Most customers and Sales are around 30th and 1st of the Month

# Sales per Day
axis = sales_train_all_df.groupby('Day')[['Sales']].mean().plot(figsize = (10, 5), marker = 'o', color = 'r')
axis.set_title("Average Sales per Day")
plt.figure()

# Customers per Day
axis = sales_train_all_df.groupby('Day')[['Customers']].mean().plot(figsize = (10, 5), marker = 'o', color = 'b')
axis.set_title("Average Customers per Day")
plt.figure()

# Let's do the same for the day of the week (note that 7 = Sunday)
axis = sales_train_all_df.groupby('DayOfWeek')[['Sales']].mean().plot(figsize = (10, 5), marker = 'o', color = 'r')
axis.set_title('Average Sales per Day of the Week')
plt.figure()

# Let's do the same for the day of the week (note that 7 = Sunday)
axis = sales_train_all_df.groupby('DayOfWeek')[['Customers']].mean().plot(figsize = (10, 5), marker = 'o', color = 'r')
axis.set_title('Average Customers per Day of the Week')
plt.figure()

# Let's plot all our Date and the Stores type as well. We just wanted to see which store type has the highest number of sales and highest number of dollars basically coming in
fig, ax = plt.subplots(figsize = (20, 10))
sales_train_all_df.groupby(['Date', 'StoreType']).mean()['Sales'].unstack().plot(ax= ax)

# I wanted to plot the bar plot and
# I wanted to do a violent plot as well fro the Promo and Sales and Customers.
plt.figure(figsize= [15, 10])

plt.subplot(211)
sns.barplot(x='Promo', y='Sales', data=sales_train_all_df)

plt.subplot(212)
sns.barplot(x = 'Promo', y = 'Customers', data = sales_train_all_df)

# Let's Violin plot for same data

plt.figure(figsize= [15, 10])

plt.subplot(211)
sns.violinplot(x = 'Promo', y = 'Sales', data = sales_train_all_df)

plt.subplot(212)
sns.violinplot(x = 'Promo', y = 'Customers', data = sales_train_all_df)

"""### Task#4 **UNDERSTAND THE INTUITION BEHIND FACEBOOK PROPHET**

## ***FACEBOOK PROPHET***

1. Prophet is open soruce software released by Facebook's core Data Science team
2. Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with Yearly, Weekly and Daily seasonality, plus holiday effects.
3.  Prophet works best with time series that have strong seasonal effects and Serveral Seasons of historical data.

* Facebook Prophet implements an additive regression model with four elements:
 * A piecewise linear, Prophet automatically picks up change points in the data and Identifies any changes in trends.
 * A yearly seasonal component modeled using Fourier Series.
 * A weekly seasonal component.
 * A holiday list that can be manually provided.
 * Additive Regression modle takes the form:
 
![Additive Regression.jpeg](data:image/jpeg;base64,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)

### **FACEBOOK PROPHET BENEFITS**

**ACCURATE AND FAST**
 
 * Facebook teams uses prohpet for accurate forecasting and planning.
 * Prophet can generate results in seconds automatic.
 * No need to perform data processing
 * Prophet works with missing data with serveral outliners.


**Domain Knowledge Integration**
* Users can tweak forecast by manually adding domain specific knowledge.

### Task#5: **TRAIN THE MODEL PART A**
"""

# Let's import Facebook Prophet library
#import prophet
#!pip install fbprophet
from fbprophet import Prophet

# Let's going to crate function check speicific Store Sales informaiton 
def sales_predictions(Store_ID, sales_df, periods):
    sales_df = sales_df[sales_df['Store'] == Store_ID]
    # Let's rename Date and Sales columns
    sales_df = sales_df[['Date', 'Sales']].rename(columns = {'Date': 'ds', 'Sales': 'y'})
    sales_df = sales_df.sort_values('ds')


    # Create Prophet Model
    model = Prophet()
    model.fit(sales_df)
    future = model.make_future_dataframe(periods = periods)
    forecast = model.predict(future)
    figure = model.predict(future)
    figure = model.plot(forecast, xlabel='Date', ylabel='Sales')
    figure2 = model.plot_components(forecast)

sales_predictions(200, sales_train_all_df, 1200)

"""### Task#6 **TRAIN THE MODEL PART B**

* **StateHoliday**: Indicates a state holiday. Normally all stores, with few exceptions, are closed on state holidays. Note that all schools are clsoed on public holidays and weekends (***a = public holiday, b = Easter Holidays, C = Christmas, 0 = None***)

* **SchoolHoliday**: Indicates if the (Store, Date) was affected by the closure of public schools.
"""

# Let's create a same function and just add holdays in the function
def sales_holidays_predictions(Store_ID, sales_df, holidays, periods):
    sales_df = sales_df[sales_df['Store'] == Store_ID]
    # Let's rename Date and Sales columns
    sales_df = sales_df[['Date', 'Sales']].rename(columns = {'Date': 'ds', 'Sales': 'y'})
    sales_df = sales_df.sort_values('ds')


    # Create Prophet Model
    model = Prophet(holidays=holidays)
    model.fit(sales_df)
    future = model.make_future_dataframe(periods = periods)
    forecast = model.predict(future)
    figure = model.predict(future)
    figure = model.plot(forecast, xlabel='Date', ylabel='Sales')
    figure2 = model.plot_components(forecast)

# Get all the dates pertaining to school holidays

schoolholidays = sales_train_all_df[sales_train_all_df['SchoolHoliday'] == 1].loc[:, 'Date'].values

schoolholidays

schoolholidays.shape

# Let's get all dates pertainin g to state holidays

stateholidays = sales_train_all_df[(sales_train_all_df['StateHoliday'] == 'a') | (sales_train_all_df['StateHoliday'] =='b') | (sales_train_all_df['StateHoliday']=='c')].loc[:,'Date'].values

stateholidays

stateholidays.shape

stateholidays = pd.DataFrame({'ds':pd.to_datetime(stateholidays), 'holiday':'stateholiday'})

stateholidays

schoolholidays = pd.DataFrame({'ds':pd.to_datetime(schoolholidays), 'holiday':'schoolholidays'})

schoolholidays

# Let's concatenate both School and State holidays
school_state_holidays = pd.concat((stateholidays, schoolholidays))

school_state_holidays

sales_holidays_predictions(6, sales_train_all_df, school_state_holidays, 600)



"""## **THAT'S ALL** ## **GREAT JOB!**"""